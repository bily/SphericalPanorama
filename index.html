<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - equirectangular panorama demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                color: #ffffff;
                padding: 5px;
                font-family:Monospace;
                font-size:13px;
                font-weight: bold;
                text-align:center;
            }

            a {
                color: #ffffff;
            }
        </style>
    </head>
    <body>

        <div id="container"></div>
        <div id="info"><a href="http://threejs.org" target="_blank">three.js webgl</a> - Sphanorama by Leonardo Galli & Tommaso Levato.</div>

        <script src="js/three.min.js"></script>
        <script src="js/OBJLoader.js"></script>
        <script src="js/MTLLoader.js"></script>
        <script src="js/OBJMTLLoader.js"></script>
        <script src="js/ajaxMysql.js"></script>
        <script src="http://code.jquery.com/jquery-2.0.3.js"></script>

        <script>
            var camera, scene, renderer, mesh;
            var objects = [];
            var fov = 70,
                    texture,
                    isUserInteracting = false,
                    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
                    lon = 0, onMouseDownLon = 0,
                    lat = 0, onMouseDownLat = 0,
                    phi = 0, theta = 0,
                    //senza latLimit "guardando" in basso si vede un buco nero
                    latLimit = -30,
                    projector, panoId = 1,
                    minZoom = 70, maxZoom = 20;

            var fadeEffect = function() {
                return{
                    init: function(id, flag, target) {
                        this.elem = document.getElementById(id);
                        clearInterval(this.elem.si);
                        this.target = target ? target : flag ? 100 : 0;
                        this.flag = flag || -1;
                        this.alpha = this.elem.style.opacity ? parseFloat(this.elem.style.opacity) * 100 : 0;
                        this.elem.si = setInterval(function() {
                            fadeEffect.tween();
                        }, 20);
                    },
                    tween: function() {
                        if (this.alpha === this.target) {
                            clearInterval(this.elem.si);
                        } else {
                            var value = Math.round(this.alpha + ((this.target - this.alpha) * .05)) + (1 * this.flag);
                            this.elem.style.opacity = value / 100;
                            this.elem.style.filter = 'alpha(opacity=' + value + ')';
                            this.alpha = value;
                        }
                    }
                };
            }();

            init();
            animate();



            function init() {
                var container = document.getElementById('container');

                camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1100);
                camera.target = new THREE.Vector3(0, 0, 0);

                scene = new THREE.Scene();
                projector = new THREE.Projector();
                getPanorama(panoId);
                var panoName = xmlhttp.responseText;
                texture = THREE.ImageUtils.loadTexture('textures/' + panoName);
                mesh = new THREE.Mesh(new THREE.SphereGeometry(500, 60, 40), new THREE.MeshBasicMaterial({map: texture}));
                mesh.scale.x = -1;
                scene.add(mesh);

                var pointLight = new THREE.PointLight(0xFFFFFF);
                scene.add(pointLight);

                var loader = new THREE.OBJMTLLoader();
                loader.addEventListener('load', function(event) {
                    //TODO: caricarli dal database
                    var object = event.content;
                    object.position.z = -10;
                    object.position.y = -3;
                    object.scale.x = 2;
                    object.scale.y = 2;
                    object.scale.z = 2;
                    scene.add(object);
                    objects.push(object);

                });

                loader.load('object/mobile.obj', 'object/mobile.mtl');

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);

                container.appendChild(renderer.domElement);

                document.addEventListener('mousedown', onDocumentMouseDown, false);
                document.addEventListener('mousemove', onDocumentMouseMove, false);
                document.addEventListener('mouseup', onDocumentMouseUp, false);
                document.addEventListener('mousewheel', onDocumentMouseWheel, false);
                document.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);

                window.addEventListener('resize', onWindowResize, false);


                renderer.domElement.addEventListener('click', function(event) {
                    event.preventDefault();
                    var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                    var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                    var vector = new THREE.Vector3(mouseX, mouseY, 0.5);
                    projector.unprojectVector(vector, camera);
                    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
                    var intersects = raycaster.intersectObjects(objects, true);
                    if (intersects[0] !== undefined)
                        //TODO: qui scelgo cosa fare con l'oggetto attuale in qualche modo
                        alert("mi hanno cliccato!");
                }, false);
                fadeEffect.init('container', 1);
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onDocumentMouseDown(event) {

                isUserInteracting = true;

                onPointerDownPointerX = event.clientX;
                onPointerDownPointerY = event.clientY;

                onPointerDownLon = lon;
                onPointerDownLat = lat;
            }

            function onDocumentMouseMove(event) {
                //TODO
                if (isUserInteracting) {

                    lon = mod(((onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon), 360);
                    var rawLat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
                    lat = Math.max(rawLat, latLimit);
                }
            }

            function onDocumentMouseUp(event) {

                isUserInteracting = false;

            }

            function onDocumentMouseWheel(event) {
                var sub = fov - event.wheelDeltaY * 0.05;
                //TODO: trovare dei nomi che abbiano senso per maxZoom e minZoom
                if (maxZoom <= sub && sub <= minZoom) {

                    // WebKit

                    if (event.wheelDeltaY) {

                        fov -= event.wheelDeltaY * 0.05;
                        // Opera / Explorer 9

                    } else if (event.wheelDelta) {

                        fov -= event.wheelDelta * 0.05;
                        // Firefox

                    } else if (event.detail) {

                        fov += event.detail * 1.0;

                    }

                    camera.projectionMatrix.makePerspective(fov, window.innerWidth / window.innerHeight, 1, 1100);
                    render();

                }
                if (sub < maxZoom) {
                    //i log servono per settare la longitude e latitudine da caricare
                    console.log("Longitude: " + lon.toString());
                    console.log("Latitude: " + lat.toString());
                    getNextPanorama(panoId);
                    var panoArray = JSON.parse(xmlhttp.response);
                    var found = false;
                    while (panoArray.length > 0 && !found) {
                        var candidate = panoArray.pop();
                        found = isNextPano(candidate);
                    }
                    if (found) {
                        fadeEffect.init('container', 0, 50);
                        setTimeout(function() {
                            panoId = candidate['ID'];
                            texture = THREE.ImageUtils.loadTexture('textures/' + candidate['Panorama'], '', function onLoad() {
                                mesh.material.map = texture;
                                fov = 70;
                                lat = -6;
                                lon = 50;
                                camera.projectionMatrix.makePerspective(fov, window.innerWidth / window.innerHeight, 1, 1100);
                                render();
                                fadeEffect.init('container', 1);
                            });
                        }, 500);
                    }
                }
            }

            function animate() {

                requestAnimationFrame(animate);
                render();

            }

            function render() {

                lat = Math.max(-85, Math.min(85, lat));
                phi = THREE.Math.degToRad(90 - lat);
                theta = THREE.Math.degToRad(lon);

                camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
                camera.target.y = 500 * Math.cos(phi);
                camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);

                camera.lookAt(camera.target);

                /*
                 // distortion
                 camera.position.x = - camera.target.x;
                 camera.position.y = - camera.target.y;
                 camera.position.z = - camera.target.z;
                 */

                renderer.render(scene, camera);
            }


            function mod(num, mod) {
                var remain = num % mod;
                return Math.floor(remain >= 0 ? remain : remain + mod);
            }

            function isNextPano(candidate) {
                return (Math.abs(lat - candidate['Latitude']) < 20 && Math.abs(lon - candidate['Longitude']) < 20);
            }



        </script>


    </body>
</html>
